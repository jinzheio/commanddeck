# 用代码“画”图标：自动化设计与踩坑记录

在构建 **CommandDeck** 的过程中，我们需要一个符合 "RimWorld" 或 "Pacific Rim" 风格的应用图标。作为一个全栈开发者（以及 AI 助手），我选择了一种工程师的方式来解决设计问题：**用代码画图，用脚本导出**。

这篇文章记录了我们如何使用 SVG、通过浏览器自动化渲染生成高清 PNG，以及解决其中遇到的宽高比和对齐 Bug 的过程。

## 1. 为什么不用 Photoshop/Figma？

虽然专业设计工具很强大，但对于开发工具类的应用，使用**SVG (Scalable Vector Graphics)** 有几个独特的优势：

1.  **版本控制**：图标是一个文本文件，可以放进 Git，改了哪里一清二楚。
2.  **可编程**：我们可以用 CSS 甚至 JS 来调整颜色、光晕和动画效果。
3.  **无限分辨率**：它是矢量的，这意味着无论我们需要 16x16 还是 1024x1024，它永远清晰锐利。

我们使用了一个简单的 HTML 文件 (`icon_design.html`) 来承载 SVG：

```html
<svg width="512" height="512" viewBox="0 0 512 512">
  <!-- 底座：圆角矩形 -->
  <rect fill="#1a1a1a" ... />
  <!-- 装饰：网格图案 -->
  <pattern id="grid" ... />
  <!-- 核心：发光的控制台 -->
  <rect fill="#4a9eff" filter="url(#glow)" ... />
</svg>
```

这段代码定义了一个深灰色的金属底座、一个发光的青色控制台和一个呼吸闪烁的光标。

## 2. 自动化导出：Playwright 的妙用

设计好了 SVG，但 Electron 打包需要 `.png` 或 `.icns` 格式的位图。通常我们可以在浏览器打开然后截图，但我们选择用 **Playwright** 来自动化这个过程。

这允许我们在构建脚本中集成“生成图标”这一步。

我们使用了一个简单的 Playwright 脚本（通过 MCP 工具执行）：

1.  把 HTML 文件转为 Base64 Data URI。
2.  启动无头浏览器 (Headless Chrome)。
3.  设置视口 (Viewport) 为 512x512。
4.  截图并保存。


## 3. 番外：为何不使用 rsvg-convert？

可能会有读者问：*为什么不用 `rsvg-convert` 或 ImageMagick 这些标准的命令行工具来转换 SVG？*

这也是我最初考虑的方案，但最终放弃了，原因有三点：

1.  **滤镜支持 (Filters)**：我们的图标使用了 `<filter id="glow">`。虽然现代浏览器渲染最准确，但实测发现 `rsvg-convert` 的渲染效果也非常出色，完全可以接受。
2.  **透明度处理**：**这是决定性因素**。浏览器的截图往往默认带有白色背景（除非专门配置复杂的透明度选项），而 `rsvg-convert` 默认输出透明背景 PNG，这对 App 图标至关重要。
3.  **效率**：`rsvg-convert` 是单一的二进制文件，转换速度极快，不需要启动庞大的浏览器进程。

## 4. 最终选择：回归 rsvg-convert

尽管我们用 Playwright 成功生成了图标（并解决了裁剪问题，如下文所述），但最终我们还是切换回了 `rsvg-convert`。

为什么？因为 **透明背景**。

在使用 Playwright 截图时，我们得到了一个带白色背景的图片。虽然可以通过代码移除背景，但这引入了额外的复杂性。而使用 `rsvg-convert`，我们一行命令就得到了完美的透明背景图标：

```bash
rsvg-convert -w 512 -h 512 -o build/icon.png icon.svg
```

虽然我们最终选择了简单的路，但这次折腾 Playwright 截图也让我们学到了不少（特别是关于视口和裁剪的坑）。以下是我们在使用浏览器方案时的踩坑记录，供通过截图生成内容的场景参考。

## 5. 踩坑记录：如果坚持用浏览器截图...

事情并没有想象中顺利。第一次生成出来的图标长这样：

![Squashed Icon](placeholder_for_squashed.png)

**现象**：图标看起来被压扁了，且左右留有奇怪的空白。

**排查**：
我们检查了生成的 PNG 文件信息：
```bash
sips -g pixelWidth -g pixelHeight build/icon.png
# Output: width: 800, height: 513
```

**原因**：
虽然我们设置了 `<svg width="512">`，但 Playwright 默认的视口宽度往往是标准的 800px 或 1280px。截图时，它截取了整个视口，而不仅仅是 SVG 元素。
当我们把这个 800x513 的长方形图片喂给 `electron-builder` 时，它被强制压缩进正方形的各个尺寸（如 256x256, 64x64），导致内容变形。

## 7. 修复：Python 的精确裁剪

我们尝试了调整视口，但发现浏览器行为有些难以预测（有时候会有默认边距）。最稳健的方法是：**后处理**。

我们引入了 Python 的 `PIL` (Pillow) 库来进行精确裁剪。

### 第一次尝试：居中裁剪
我最初以为 SVG 是居中的，所以写了一个“居中裁剪”脚本：
```python
left = (width - 512)/2
img = img.crop((left, top, ...))
```
**结果**：图标偏向了一侧，右边是大片空白。

**真相**：HTML 默认是从左上角 `(0,0)` 开始渲染元素的，而不是居中。当我们从中间裁剪时，我们实际上是把左边的图标切掉了一半，保留了右边的空白。

### 最终方案：左上角裁剪
我们要做的非常简单——既然 SVG 本身就是 512x512 且位于 `(0,0)`，我们只需要截取图片的左上角即可。

```python
from PIL import Image
img = Image.open('raw_screenshot.png')
# Crop: (left, top, right, bottom)
img = img.crop((0, 0, 512, 512))
img.save('build/icon.png')
```

## 8. 总结

这一番折腾下来，我们得到了一个完美的、自动化生成的应用图标。它不仅解决了设计问题，更重要的是，它证明了**用工程思维解决设计问题**的可行性。

下次你需要一个简单的 App 图标时，不妨试试写点 SVG，然后让 CI 系统自动为你生成！
